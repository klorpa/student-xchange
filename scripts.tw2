::GeneralFunctions [script] <200,50>

setup.getDefaultName = function () {
	const unusedPopularNames = ["Madison","Abigail","Taylor","Alyssa","Lauren","Brianna","Anna","Megan","Destiny","Jasmine","Jennifer","Julia","Isabella","Morgan"]
	const randomIndex = Math.floor(Math.random() * unusedPopularNames.length)
	return unusedPopularNames[randomIndex]
}

setup.removeItem = function (arr, item) {
	var index = arr.indexOf(item)
	if (index < 0) {
		return arr
	} else {
  	return arr.slice(0,index).concat(arr.slice(index+1))
	}
}

setup.addIfNeeded = function (arr, item) {
	var index = arr.indexOf(item)
	if (index < 0) {
		return arr.concat([item])
	} else {
		return arr
	}
}

::AutoNav [script] <250,50>
var IntervalID = setInterval(UpdateLinks, 300);

$(document).on(':passageend', function (ev) {
	clearInterval(IntervalID);
	IntervalID = setInterval(UpdateLinks, 300);  // Triggers UpdateLinks() 300ms after the passage is rendered.
});

// Search passages for links every 300ms and marks them for key clicks
function UpdateLinks() {
	if (Engine.isIdle()) {
		var Links = $("#passages a");
		if (Links.length === 1) {
			Links[0].id = "NextLink";
		} else if (Links.length >= 1 && Links.length <= 10) {
			var n = 1;
			for (var i = 0; i < Links.length; i++) {
				if (!Links[i].id.includes("Link")) {
					while ($('#Link' + n).length) {
						++n;
						if (n > 10) {
							break;
						}
					}

					if (n < 10) {
						$("<sup>[" + n + "]</sup>").appendTo(Links[i]);
						Links[i].id = "Link" + n;
					} else if (n === 10) {
						$("<sup>[0]</sup>").appendTo(Links[i]);
						Links[i].id = "Link0";
					}
					if (n >= 10) {
						break;
					}
				}
			}
		}
	}
};

$(document).on("keyup", function (e) {
	// Trigger next link click on right arrow key
	if (((e.key == "ArrowRight") || (e.keyCode == 49) || (e.keyCode == 97)) && $("#NextLink").length && (!tags().includes("DisableClick"))) {
		e.preventDefault();
		$("#NextLink").trigger("click");
		return false;
	}

	// Trigger link click on keys "0" through "9"
	if ((e.keyCode > 47) && (e.keyCode < 58) && (!tags().includes("DisableClick"))) {
		if ($("#Link" + (e.keyCode - 48)).length) {
			e.preventDefault();
			$("#Link" + (e.keyCode - 48)).trigger("click");
			return false;
		}
	}
	if ((e.keyCode > 95) && (e.keyCode < 106) && (!tags().includes("DisableClick"))) {
		if ($("#Link" + (e.keyCode - 96)).length) {
			e.preventDefault();
			$("#Link" + (e.keyCode - 96)).trigger("click");
			return false;
		}
	}

	// Trigger random click on ".", "`", and "r" keys
	if (([".", "`", "r"].includes(e.key)) && (!tags().includes("DisableClick"))) {
		e.preventDefault();
		var Links = $("#passages a");
		if (Links.length > 0) {
			Links[Math.floor(Math.random() * Links.length)].click();
			return false;
		}
	}

	// Trigger back click on left arrow key
	if ((e.key == "ArrowLeft") && (!tags().includes("DisableClick"))) {
		e.preventDefault();
		Engine.backward();
		return false;
	}
});

::InventoryFunctions [script] <275,50>
setup.addInventory = function (itemClass, itemName) {
  if (!state.active.variables.inventory[itemClass]) {
    state.active.variables.inventory[itemClass] = []
  }
  state.active.variables.inventory[itemClass] = setup.addIfNeeded(state.active.variables.inventory[itemClass], itemName)
}

setup.haveInventory = function (itemClass, itemName) {
  if (!state.active.variables.inventory[itemClass]) {
    return false
  } else {
    return state.active.variables.inventory[itemClass].indexOf(itemName) >= 0
  }
}

setup.removeInventory = function(itemClass, itemName) {
  if (setup.haveInventory(itemClass, itemName)) {
    state.active.variables.inventory[itemClass] = setup.removeItem(state.active.variables.inventory[itemClass], itemName)
    return true;
  } else {
    return false;
  }
}

setup.listInventory = function(itemClass) {
  if (!state.active.variables.inventory[itemClass]) {
    return "none"
  } else {
    return state.active.variables.inventory[itemClass].join(", ")
  }
  
}

::MenstrationFunctions [script] <295,50>
setup.startPeriod = function () {
  //todo
}

setup.nextCycleWeek = function () {
  //todo
}

::SexFunctions [script] <300,50>
setup.sexCount = function () {
	return state.active.variables.sex.length
}

setup.sexMaleCount = function () {
	return state.active.variables.sex.filter(function(fuck) {return fuck.sex == 'male'}).length
}

setup.sexFemaleCount = function () {
	return state.active.variables.sex.filter(function(fuck) {return fuck.sex == 'female'}).length
}

setup.sexVaginalCount = function () {
	return state.active.variables.sex.filter(function(fuck) {return fuck.sex == 'male' && fuck.vaginal}).length
}

setup.sexUniquePartners = function (fucks) {
	var named = fucks.filter(function(fuck) {return fuck.name})
	var names = named.map(function(namedFuck) {return namedFuck.name})
	return Array.from(new Set(names))
}

setup.sexAllUniquePartners = function () {
	return setup.sexUniquePartners(state.active.variables.sex)
}

setup.sexUniqueCount = function (fucks) {
	var unnamed = fucks.filter(function(fuck) {return !fuck.name})
	return unnamed.length + setup.sexUniquePartners(fucks).length
}

setup.sexUniqueMaleCount = function () {
	return setup.sexUniqueCount(state.active.variables.sex.filter(function(fuck) {return fuck.sex == 'male' && !fuck.repeat}))
}

setup.sexUniqueFemaleCount = function () {
	return setup.sexUniqueCount(state.active.variables.sex.filter(function(fuck) {return fuck.sex == 'female' && !fuck.repeat}))
}

setup.sexUniqueVaginalCount = function () {
	return setup.sexUniqueCount(state.active.variables.sex.filter(function(fuck) {return fuck.sex == 'male' && fuck.vaginal && !fuck.repeat}))
}

setup.isGoldStarLesbian = function () {
	return setup.sexVaginalCount() == 0 && setup.sexFemaleCount() > 0
}

setup.getPartnerName = function(fuck) {
  if (fuck.name) {
    var kidnapperNote = (state.active.variables.KidnapEscape && fuck.name.indexOf("Kidnapper") >= 0) ? " (no memory)" : ""
    return fuck.name + kidnapperNote
  } else if (fuck.anon) {
    return "Some " + fuck.anon
  } else if (fuck.sex == 'male') {
    return "Some Guy"
  } else {
    return "Some Girl"
  }
}

setup.sexualHistoryTable = function () {
	if (!state.active.variables.sex || state.active.variables.sex.length == 0) {
		return "You are still a virgin.  You must be new here."
	}

	var st = "<table>\n<tr><th>Name / Description</th><th>M/F</th><th>Vaginal?</th><th>Birth Control</th><th>Pregnancy</th></tr>\n"
	state.active.variables.sex.forEach(function (fuck) {
		st += "<tr><td>"
    var partnerName = setup.getPartnerName(fuck)
    if (partnerName.indexOf("Some") >= 0) {
      st += "<i>(" + partnerName + ")</i>"
    } else {
      st += partnerName
    }
		st += "</td><td>" + fuck.sex + "</td><td>" + (fuck.vaginal ? "Y" : "") + "</td><td>"
			 + (fuck.vaginal ? fuck.birthControl : "")
			 + (fuck.ovulating ? " (ovulating) " : "")
			 + "</td><td>"
    if (fuck.conception) {
      if (fuck.aborted) {
        st += "(Aborted)"
      } else {
        st += "CONCEPTION"
      }
    } else if (fuck.checkedForPregnancy) {
      st += "no: " + fuck.checkedForPregnancy
    } else if (fuck.vaginal) {
      st += "?"
    }
    st += "</td></tr>\n"
	})
  return st + "</table>\n"
}


setup.haveFucked = function (name) {
	return state.active.variables.sex.filter(function(fuck) {return fuck.name == name || fuck.anon == name}).length > 0
} 

setup.haveFuckedMale = function (name) {
	return state.active.variables.sex.filter(function(fuck) {return fuck.sex == 'male' && (fuck.name == name || fuck.anon == name)}).length > 0
} 

setup.haveFuckedVaginal = function (name) {
	// different than daddyCheck, since doesn't care about birth control
	return state.active.variables.sex.filter(function(fuck) {return fuck.vaginal && (fuck.name == name || fuck.anon == name)}).length > 0
} 

setup.fuckedVaginalCount = function (name) {
	return state.active.variables.sex.filter(function(fuck) {return fuck.vaginal && (fuck.name == name || fuck.anon == name)})
}

setup.addDetailsToRecentSex = function() {
	if (!state.active.variables.sex) return;

	state.active.variables.sex.forEach(function(fuck) {
		if(fuck.vaginal && !fuck.checkedForPregnancy) {
      if (!fuck.birthControl) {
        if (state.active.variables.PlayerPregnant) {
          fuck.birthControl = 'pregnant'
        } else if (state.active.variables.PlayerProtectionPerfect) {
          fuck.birthControl = 'implant-perfect'
				} else if (state.active.variables.PlayerProtectionPrince) {
					fuck.birthControl = 'injection'
        } else if (fuck.birthControlOverride) {
          fuck.birthControl = fuck.birthControlOverride
        } else if (state.active.variables.PlayerProtectionPermanent) {
          fuck.birthControl = 'implant-pill'
        } else if (state.active.variables.PlayerProtectionPill && !fuck.noPill) {
          fuck.birthControl = 'pill'
        } else if ((state.active.variables.PlayerProtectionCondoms && !fuck.noCondom) || fuck.condom) {
          fuck.birthControl = 'condom'
        } else if ((state.active.variables.PlayerProtectionWithdraw && !fuck.noPullout)  || fuck.pullout) {
          fuck.birthControl = 'pullout'
        } else {
          fuck.birthControl = 'none'
        }
      }

      if (state.active.variables.PlayerProtectionTry) {
        fuck.trying = true
      }

      if (fuck.birthControl == 'pregnant') {
        fuck.checkedForPregnancy = 'already pregnant'
      } else if (fuck.birthControl == 'implant-perfect') {
        fuck.checkedForPregnancy = 'perfect implant'
      } else if (fuck.birthControl == 'injection') {
        fuck.checkedForPregnancy = 'injection'
      } else if (fuck.birthControl == 'cycle') {
        fuck.checkedForPregnancy = 'wrong time of month'
      } else if (fuck.birthControl == 'vasectomy') {
        fuck.checkedForPregnancy = 'partner had vasectomy'
      } else if (fuck.birthControl == 'pullout-perfect') {
        fuck.checkedForPregnancy = 'early pullout'
      } else if (fuck.birthControl == 'goo') {
        fuck.checkedForPregnancy = 'sample did not contain sperm'
      } else if (fuck.birthControl == 'careful condom') {
        fuck.checkedForPregnancy = 'condom (careful)'
      }
		}
	})
}

setup.getPossibleConceptions = function() {
  setup.addDetailsToRecentSex()
  return state.active.variables.sex.filter(function(fuck) {
    return fuck.vaginal &&
      !fuck.checkedForPregnancy &&
      fuck.birthControl != 'pregnant' &&
      fuck.birthControl != 'implant-perfect' &&
      fuck.birthControl != 'injection' &&
      fuck.birthControl != 'cycle' &&
      fuck.birthControl != 'vasectomy' &&
      fuck.birthControl != 'pullout-perfect' &&
			fuck.birthControl != 'goo'
  })
}

setup.pregnantFirstTime = function() {
  const intercourse = state.active.variables.sex.filter(function(fuck) {return fuck.vaginal})
  return intercourse.length && intercourse[0].conception && !intercourse[0].trying
}

setup.notPregnant = function(reason) {
  setup.getPossibleConceptions().forEach(function(fuck) {
    fuck.checkedForPregnancy = reason
  })
}

setup.checkForPregnancy = function (fuck, oddsBoost, ovulationOverride) {
  var ovulationTableNormal = [
    0, 0, 0, 0, 0, 0, 0,
    0.1, 0.1, 0.2, 0.5, 0.5, 0.5, 0.5,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    0.5, 0.5, 0.5, 0.5, 0.2, 0.1, 0.1
  ]
  var ovulationTableExtraFertile = [
    0, 0, 0, 0.1, 0.1, 0.2, 0.2, 0.5,
    0.5, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 0.5, 0.2, 0.2, 0.1, 0.1
  ]
             
  var ovulationRoll = Math.floor(Math.random() * 28)
  var baseProbability
  if (ovulationOverride) {
    baseProbability = state.active.variables.PlayerProtectionFertile ? 1.0 : 0.6
  } else if (state.active.variables.PlayerProtectionFertile) {
    baseProbability = ovulationTableExtraFertile[ovulationRoll]
  } else {
    baseProbability = ovulationTableNormal[ovulationRoll]
  }

  var protectionFactor = 1.0
  if (fuck.birthControl == 'implant-pill') {
    protectionFactor = 0.02
  } else if (fuck.birthControl == 'pill' && fuck.name == 'Aaron') {
    protectionFactor = 0.02
  } else if (fuck.birthControl == 'pill' && !fuck.ovulating) {
    protectionFactor = 0.05
  } else if (fuck.birthControl == 'condom') {
    protectionFactor = 0.1
  } else if (fuck.birthControl == 'pullout') {
    protectionFactor = 0.2
  }

  var conceptionRoll = Math.random() * baseProbability * protectionFactor
  return (conceptionRoll + oddsBoost) >= 0.5
}

setup.checkForNewPregnancy = function(pregnancyTestType, oddsBoost) {
  if (state.active.variables.PlayerPregnant) {
    return {isPregnant: false, possibleFathers: []} // already pregnant
  } else {
    var recentVaginal = setup.getPossibleConceptions()
    var possibleFathers = Array.from(new Set(recentVaginal.map(function(fuck) {
      return setup.getPartnerName(fuck)
    })))
    
    var isPregnant, actualFather, conceptionEvent
    recentVaginal.forEach(function(fuck) {
      if (isPregnant) {
        fuck.checkedForPregnancy = "already pregnant"
      } else {
				var areDefinitelyOvulating = (fuck.ovulating && !state.active.variables.PlayerProtectionPill) || fuck.noPill
        fuck.conception = setup.checkForPregnancy(fuck, oddsBoost, areDefinitelyOvulating)
        fuck.checkedForPregnancy = pregnancyTestType
        if (fuck.conception) {
          isPregnant = true // but player doesn't know yet, so don't set visible state variable
          conceptionEvent = fuck
          actualFather = setup.getPartnerName(fuck)
        }
      }
    })

    return {isPregnant, possibleFathers, actualFather, conceptionEvent, count: recentVaginal.length}
  }
}

setup.overrideForcePregnancy = function(pregnancyTestType) {
  var recentVaginal = setup.getPossibleConceptions()
	var normalCheck = setup.checkForNewPregnancy(pregnancyTestType, 0.25)

  if (state.active.variables.PlayerPregnant || normalCheck.isPregnant) {
		// pregnant without override, do nothing extra
		return normalCheck 
	} else {
		// they somehow managed to not get pregnant, but the story expects them to, so lets fix that

		if (recentVaginal.length === 0) {
			// how did we end up here? This shouldn't have been called if they aren't sleeping with any guys.  Aborting pregnancy override
			return normalCheck
		}

    var possibleFathers = Array.from(new Set(recentVaginal.map(function(fuck) {
      return setup.getPartnerName(fuck)
    })))

		var luckyFuck = recentVaginal[Math.floor(Math.random() * recentVaginal.length)]
		luckyFuck.conception = true

		return {
			isPregnant: true,
			possibleFathers,
			conceptionEvent: luckyFuck,
			actualFather: setup.getPartnerName(luckyFuck),
			count: recentVaginal.length
		}
	}
}

::LibidoFunctions [script] <325,50>
setup.libido = function (delta) {
  if (state.active.variables.Libido) {
    state.active.variables.Libido += delta;
  } else {
    state.active.variables.Libido = delta;
  }
  if (state.active.variables.Libido > 100) {
    state.active.variables.Libido = 100
  } else if (state.active.variables.Libido < 0) {
    state.active.variables.Libido = 0
  }
}

::NeighbourFunctions [script] <350,50>
setup.addNeighbour = function (name) {
	return state.active.variables.neighbours.push(name)
}

setup.isNeighbour = function (name) {
	return state.active.variables.neighbours.indexOf(name) >= 0
}

setup.removeNeighbour = function (name) {
	state.active.variables.neighbours = setup.removeItem(state.active.variables.neighbours, name)
}

::DatingFunctions [script] <400,50>
setup.startDating = function (name) {
	state.active.variables.exes = setup.removeItem(state.active.variables.exes, name)
	state.active.variables.dating = setup.addIfNeeded(state.active.variables.dating, name)
	state.active.variables.fwb = setup.removeItem(state.active.variables.fwb, name)
	state.active.variables.friendzone = setup.removeItem(state.active.variables.friendzone, name)
}

setup.breakupWith = function (name) {
	state.active.variables.exes = setup.addIfNeeded(state.active.variables.exes, name)
	state.active.variables.dating = setup.removeItem(state.active.variables.dating, name)
	state.active.variables.fwb = setup.removeItem(state.active.variables.fwb, name)
	state.active.variables.friendzone = setup.removeItem(state.active.variables.friendzone, name)
}

setup.makeFWB = function(name) {
	state.active.variables.exes = setup.removeItem(state.active.variables.exes, name)
	state.active.variables.dating = setup.removeItem(state.active.variables.dating, name)
	state.active.variables.fwb = setup.addIfNeeded(state.active.variables.fwb, name)
	state.active.variables.friendzone = setup.removeItem(state.active.variables.friendzone, name)
}

setup.friendZone = function(name) {
	state.active.variables.exes = setup.removeItem(state.active.variables.exes, name)
	state.active.variables.dating = setup.removeItem(state.active.variables.dating, name)
	state.active.variables.fwb = setup.removeItem(state.active.variables.fwb, name)
	state.active.variables.friendzone = setup.addIfNeeded(state.active.variables.friendzone, name)
}

setup.areDating = function (name) {
	return state.active.variables.dating.indexOf(name) >= 0
}

setup.isEx = function (name) {
	return state.active.variables.exes.indexOf(name) >= 0
}

setup.haveDated = function (name) {
	return setup.areDating(name) || setup.isEx(name)
}

setup.isFWB = function(name) {
	return state.active.variables.fwb.indexOf(name) >= 0
}

setup.isFriendzoned = function(name) {
	return state.active.variables.friendzone.indexOf(name) >= 0
}

::EventFunctions [script] <405,50>
$(document).on(':passagestart', function (ev) {
	setup.addDetailsToRecentSex()
})

::AchievementFunctions [script] <417,50>
setup.getAchievementDetails = function() {
	return {
		married: {text: "Married", image: "Married.png"},
		mileHigh: {text: "Mile High Club", image: "MileHigh.gif"},
		pregnant: {text: "Pregnant", image: "Pregnant.jpg"},
		mother: {text: "Gave Birth", image: "Baby.jpg"},
		childfree: {text: "Childfree", image: "NoBaby.png"},
		dropout: {text: "Dropped out of College", image: "DropOut.png"},
		train: {text: "Serving a Train", image: "Train.jpg"},
		threesome: {parts: ["MFM", "FMF", "FFF"], text: "Three Threesomes: MFM, FMF, and FFF", image: "Threesome.png"},
		underdog: {text: "Underdog Wins", image: "Underdog.jpg"},
    girlpower: {text: "Choosing This Life", image: "GirlPower.png"},
    friends: {text: "Reuniting with Old Friends", image: "Friends.jpg"},
    sisters: {text: "Three Sisters", image: "Sisters.jpg"},
    firsttime: {text: "Beginner's Luck", image: "FirstTime.jpg"},
    graduate: {text: "Graduated College", image: "Graduate.jpg"},

		slave: {text: "Enslaved", image: "Slave.jpg", isEnding: true},
		cumslut: {text: "Cum Slut", image: "Cumslut.png", isEnding: true},
		kenWife: {text: "Artist's Muse", image: "Art.jpg", isEnding: true},
		andrewLargeFamily: {text: "Large Family", image: "LargeFamily.jpg", isEnding: true},
		andrewSmallFamily: {text: "Small Family", image: "SmallFamily.png", isEnding: true},
		paulWife: {text: "Trophy Wife", image: "TrophyWife.jpg", isEnding:true},
		memoryWipe: {text: "Memory Wipe", image: "CleanMind.jpg", isEnding:true},
		concubine: {text: "Prince's Concubine", image: "Concubine.jpg", isEnding:true},
		resortPet: {text: "Permanent Vacation", image: "Pet.jpg", isEnding:true},
    breedingPet: {text: "Breeding Pet", image: "BreederPet.jpg", isEnding:true},
    chastity: {text: "Chaste Wife", image: "Chastity.jpg", isEnding:true},
    breeder: {text: "Professional Surrogate", image: "Breeder.jpg", isEnding:true},
    uncle: {text: "Submissive Wife", image: "Uncle.png", isEnding:true},
    stepmom: {text: "Stepmother", image: "StepMother.png", isEnding:true},
	}
}

setup.getAchievements = function() {
	const achievements = localStorage.getItem("student-x-change-program.achievements")
	if (achievements) {
		return JSON.parse(achievements)
	} else {
		return []
	}
}

setup.getAchievementSaveData = function() {
	const achievements = localStorage.getItem("student-x-change-program.achievements")
	return btoa(achievements)
}

setup.restoreLoadedAchievementData = function(saveData) {
	try {
		const achievements = JSON.parse(atob(saveData))
		if (achievements.length > 0) {
			setup.saveAchievements(achievements)
			return true
		} else {
			console.error("Empty achievements load attempted")
			return false
		}
	} catch (ex) {
		console.error(ex)
		return false		
	}
}

setup.saveAchievements = function(achievements) {
	localStorage.setItem("student-x-change-program.achievements", JSON.stringify(achievements))
}

setup.addMultipartAchievement = function(achId) {
	const currAchievements = setup.getAchievements()
	if (currAchievements.indexOf(achId) < 0) {
		const newAchievements = currAchievements.concat([achId])
		setup.saveAchievements(newAchievements)
	}
		
	const mainAchId = achId.split(":")[0]
	const achInfo = setup.getAchievementDetails()[mainAchId]
	if (!achInfo || !achInfo.parts || !achInfo.parts.length) return false

	let hasAllParts = true
	achInfo.parts.forEach((part) => {
		if (!setup.hasAchievement(`${mainAchId}:${part}`)) {
			hasAllParts = false
		}
	})

	return hasAllParts && setup.addAchievement(mainAchId)
}

setup.addAchievement = function(achId) {
	if (achId.indexOf(":") >= 0) {
		return setup.addMultipartAchievement(achId)
	}

	const currAchievements = setup.getAchievements()
	if (currAchievements.indexOf(achId) < 0) {
		const newAchievements = currAchievements.concat([achId])
		setup.saveAchievements(newAchievements)
		return true
	} else {
		return false
	}
}

setup.clearAchievements = function() {
	setup.saveAchievements([])
}

setup.hasAchievement = function(achId) {
	return setup.getAchievements().indexOf(achId) >= 0
}

setup.getAchievementCount = function() {
	return setup.getAchievements().filter((achId) => {return achId.indexOf(":") < 0}).length
}

setup.getPossibleEndings = function() {
	const details = setup.getAchievementDetails()
	let endings = []
	for (let ach in details) {
		if (details[ach].isEnding) {
			endings.push(ach)
		}
	}
	return endings
}

setup.getAchievementTable = function() {
	var st = "<table>\n"

	const achToRow = (achId) => {
		const achInfo = setup.getAchievementDetails()[achId]
		if (achId.indexOf(":") >= 0) {
			return ""
		} else if (!achInfo) {
		 	return "<tr><td colspan=2>Unknown Achievement: " + achId + "</td></tr>\n"
		} else if (achInfo.isEnding) {
		 	return ""
		} else {
			const imgText = (achInfo.image) ? "<img src=\"PartAch/" + achInfo.image + "\" hspace=\"10\" vspace=\"10\" height=\"100\" align=\"left\"/>" : ""
		 	return "<tr><td>" + imgText + "</td><td>" + achInfo.text + "</td></tr>\n"	
		}
	}

	st += setup.getAchievements().map(achToRow).join("")

	st += "</table>\n"
	return st
}

setup.getAchievementEndingTable = function() {
	var st = "<table>\n"

	const achToRow = (achId) => {
		const achInfo = setup.getAchievementDetails()[achId]
		if (achInfo && achInfo.isEnding) {
			const imgText = (achInfo.image) ? "<img src=\"PartAch/" + achInfo.image + "\" hspace=\"10\" vspace=\"10\" height=\"100\" align=\"left\"/>" : ""
		 	return "<tr><td>" + imgText + "</td><td>" + achInfo.text + "</td></tr>\n"	
		} else {
		 	return ""
		}
	}

	st += setup.getAchievements().map(achToRow).join("")

	st += "</table>\n"
	return st
}

setup.getAchievementEndingCount = function() {
	return setup.getAchievements().filter((ach) => {
		const achInfo = setup.getAchievementDetails()[ach]
		return achInfo && achInfo.isEnding
	}).length
}

setup.getTotalEndingCount = function() {
	return setup.getPossibleEndings().length
}

::Achievement [script] <450,50>
// adapted from notify.js, by chapel; for sugarcube 2 version 1.0.0
$(document.body).append("<div id='achievement'></div>");
$(document).on(':achievement', function (e) {
    if (e.message && typeof e.message === 'string') {
        // trim message
        const achId = e.message.trim();

				let achInfo = setup.getAchievementDetails()[achId]
				if (!achInfo) {
					achInfo = { text: "Unknown Achievement: " + achId }
				}

				const imageText = achInfo.image ? "<img src=\"PartAch/" + achInfo.image + "\" height=\"200\">" : ""				
				const endingText = achInfo.isEnding ? "The End: " : ""
				e.message = imageText + (endingText + achInfo.text).replace(" ","&nbsp;")
				
        // classes
        if (e.class) {
            if (typeof e.class === 'string') {
                e.class = 'open macro-achievement ' + e.class;
            } else if (Array.isArray(e.class)) {
                e.class = 'open macro-achievement ' + e.class.join(' ');
            } else {
                e.class = 'open macro-achievement';
            }
        } else {
            e.class = 'open macro-achievement';
        }
        
        // delay
        if (e.delay) {
            if (typeof e.delay !== 'number') {
                e.delay = Number(e.delay)
            }
            if (Number.isNaN(e.delay)) {
                e.delay = 5000;
            }
        } else {
            e.delay = 5000;
        }
        
        $('#achievement')
            .empty()
            .wiki(e.message)
            .addClass(e.class)
                
        setTimeout(function () {
            $('#achievement').removeClass();
        }, e.delay);
    }
});

// <<achievement delay 'classes'>> message <</achievement>>
Macro.add('achievement', {
       tags : null,
    handler : function () {
        
        // set up
        var msg     = this.payload[0].contents, 
            time    = false, 
            classes = false, i;
        
        // arguments
        if (this.args.length > 0) {
            if (typeof this.args[0] === 'number') {
                time    = this.args[0];
                classes = (this.args.length > 1) ? this.args.slice(1).flatten() : false;
            } else {
                classes = this.args.flatten().join(' ');
            }
        }

				const isMultiPart = (msg.indexOf(":") >= 0)

				if (msg.indexOf(":") >= 0) {
					if (setup.addMultipartAchievement(msg)) {
						// fire event
						$(document).trigger({
								type    : ':achievement',
								message : msg.split(":")[0],
								delay   : time,
								class   : classes
						});
					}
				} else {
					if (setup.addAchievement(msg)) {
						// fire event
						$(document).trigger({
								type    : ':achievement',
								message : msg,
								delay   : time,
								class   : classes
						});
					}
				}
    }
});

::PassageHeader <475,50>
<span style="display:none"><<if $playerName>>$playerName<<if $MindBlank>>/Marie<</if>>: <</if>></span>
